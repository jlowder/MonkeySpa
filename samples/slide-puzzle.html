<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slide Puzzle</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background: linear-gradient(135deg, #1a4d2e 0%, #2d5a3d 25%, #1a4d2e 50%, #2d5a3d 75%, #1a4d2e 100%);
    background-size: 400% 400%;
    animation: marble 8s ease-in-out infinite;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

@keyframes marble {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

.game-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    align-items: center;
}

.puzzle-container {
    border: 3px solid #000;
    border-radius: 8px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.1);
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.puzzle-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 4px;
    width: 300px;
    height: 300px;
    background: #000;
    padding: 4px;
    border-radius: 4px;
}

.puzzle-tile {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    user-select: none;
    position: relative;
    border: 2px solid #333;
    transform: translate(0, 0);
}

.puzzle-tile:hover {
    transform: scale(1.05) translate(0, 0);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.puzzle-tile.sliding {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 10;
}

.puzzle-tile.odd {
    background: linear-gradient(145deg, #ff4444, #cc3333);
    color: #ffd700;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

.puzzle-tile.even {
    background: linear-gradient(145deg, #ffffff, #f0f0f0);
    color: #ffd700;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
}

/* Tile Color Variations */
.puzzle-tile.odd.red { background: linear-gradient(145deg, #ff4444, #cc3333); }
.puzzle-tile.odd.blue { background: linear-gradient(145deg, #4444ff, #3333cc); }
.puzzle-tile.odd.green { background: linear-gradient(145deg, #44ff44, #33cc33); }
.puzzle-tile.odd.purple { background: linear-gradient(145deg, #8844ff, #6633cc); }
.puzzle-tile.odd.orange { background: linear-gradient(145deg, #ff8844, #cc6633); }
.puzzle-tile.odd.pink { background: linear-gradient(145deg, #ff4488, #cc3366); }
.puzzle-tile.odd.teal { background: linear-gradient(145deg, #44ffff, #33cccc); }
.puzzle-tile.odd.brown { background: linear-gradient(145deg, #aa6644, #885533); }

.puzzle-tile.even.white { background: linear-gradient(145deg, #ffffff, #f0f0f0); }
.puzzle-tile.even.lightgray { background: linear-gradient(145deg, #dddddd, #cccccc); }
.puzzle-tile.even.lightblue { background: linear-gradient(145deg, #aaddff, #99ccdd); }
.puzzle-tile.even.lightgreen { background: linear-gradient(145deg, #aaffaa, #99dd99); }
.puzzle-tile.even.lightyellow { background: linear-gradient(145deg, #ffffaa, #dddd99); }
.puzzle-tile.even.lightpink { background: linear-gradient(145deg, #ffaadd, #dd99cc); }
.puzzle-tile.even.lightcyan { background: linear-gradient(145deg, #aaffff, #99dddd); }
.puzzle-tile.even.beige { background: linear-gradient(145deg, #f5f5dc, #e5e5cc); }

.puzzle-tile.empty {
    background: #000;
    border: 2px solid #333;
    cursor: default;
}

.puzzle-tile.empty:hover {
    transform: none;
    box-shadow: none;
}

.control-panel {
    border: 3px solid #000;
    border-radius: 8px;
    padding: 20px;
    background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
    background-image: 
        repeating-linear-gradient(
            45deg,
            transparent,
            transparent 10px,
            rgba(255, 255, 255, 0.05) 10px,
            rgba(255, 255, 255, 0.05) 20px
        );
    display: flex;
    gap: 30px;
    align-items: center;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.stats {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.stat-box {
    text-align: center;
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #444;
}

.stat-value {
    font-size: 24px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
}

.stat-value#timer {
    color: #00ff00;
    text-shadow: 0 0 10px #00ff00;
}

.stat-value#moves {
    color: #ffff00;
    text-shadow: 0 0 10px #ffff00;
}

.stat-label {
    color: #fff;
    font-size: 12px;
    margin-top: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.control-btn {
    padding: 12px 24px;
    font-size: 14px;
    font-weight: bold;
    color: #fff;
    background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
    border: 2px solid #666;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 2px 4px rgba(0, 0, 0, 0.3);
}

.control-btn:hover {
    background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
    transform: translateY(-2px);
    box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        0 4px 8px rgba(0, 0, 0, 0.4);
}

.control-btn:active {
    transform: translateY(0);
    box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.3),
        0 1px 2px rgba(0, 0, 0, 0.2);
}

.control-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

/* Modal Styles */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
    border: 3px solid #000;
    border-radius: 12px;
    padding: 0;
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
}

.modal-header {
    background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
    padding: 20px;
    border-bottom: 2px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h2 {
    color: #fff;
    margin: 0;
    font-size: 24px;
}

.close-btn {
    background: none;
    border: none;
    color: #fff;
    font-size: 28px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background 0.2s ease;
}

.close-btn:hover {
    background: rgba(255, 255, 255, 0.1);
}

.modal-body {
    padding: 20px;
}

.option-group {
    margin-bottom: 25px;
}

.option-group h3 {
    color: #fff;
    margin: 0 0 15px 0;
    font-size: 18px;
    border-bottom: 1px solid #444;
    padding-bottom: 8px;
}

/* Toggle Switch Styles */
.toggle-option {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
}

.toggle-option label {
    color: #fff;
    font-size: 16px;
    cursor: pointer;
    flex: 1;
}

.toggle-option input[type="checkbox"] {
    display: none;
}

.toggle-slider {
    position: relative;
    width: 50px;
    height: 24px;
    background: #444;
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.3s ease;
    display: inline-block;
}

.toggle-slider:before {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 20px;
    height: 20px;
    background: #fff;
    border-radius: 50%;
    transition: transform 0.3s ease;
}

.toggle-option input[type="checkbox"]:checked + .toggle-slider {
    background: #00ff00;
}

.toggle-option input[type="checkbox"]:checked + .toggle-slider:before {
    transform: translateX(26px);
}

/* Color Selection Styles */
.color-option {
    margin-bottom: 15px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
}

.color-option label {
    color: #fff;
    font-size: 16px;
    display: block;
    margin-bottom: 8px;
}

.color-option select {
    width: 100%;
    padding: 8px 12px;
    background: #333;
    color: #fff;
    border: 2px solid #555;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
}

.color-option select:focus {
    outline: none;
    border-color: #00ff00;
}

.modal-footer {
    padding: 20px;
    border-top: 2px solid #444;
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

.modal-footer .control-btn {
    padding: 8px 16px;
    font-size: 12px;
}

/* Hidden stats */
.stat-box.hidden {
    display: none;
}

/* Win celebration effects */
.puzzle-grid.solved {
    animation: celebration 2s ease-in-out;
    box-shadow: 0 0 30px #00ff00;
}

@keyframes celebration {
    0%, 100% { transform: scale(1); }
    25% { transform: scale(1.05); }
    50% { transform: scale(1.1); }
    75% { transform: scale(1.05); }
}

.win-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    animation: fadeIn 0.5s ease-in-out;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.win-content {
    background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
    border: 3px solid #00ff00;
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
    animation: slideIn 0.5s ease-out;
}

@keyframes slideIn {
    from { 
        transform: translateY(-50px);
        opacity: 0;
    }
    to { 
        transform: translateY(0);
        opacity: 1;
    }
}

.win-content h1 {
    color: #00ff00;
    margin: 0 0 15px 0;
    font-size: 28px;
    text-shadow: 0 0 10px #00ff00;
}

.win-content p {
    color: #fff;
    font-size: 18px;
    margin: 0 0 25px 0;
}

.win-stats {
    display: flex;
    justify-content: space-around;
    margin: 25px 0;
    padding: 20px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    border: 1px solid #444;
}

.win-stat {
    text-align: center;
}

.win-label {
    display: block;
    color: #ccc;
    font-size: 14px;
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.win-value {
    display: block;
    color: #00ff00;
    font-size: 24px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 5px #00ff00;
}

.win-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 25px;
}

.win-buttons .control-btn {
    padding: 12px 24px;
    font-size: 14px;
}

/* Responsive design */
@media (max-width: 600px) {
    .game-container {
        gap: 15px;
    }
    
    .puzzle-grid {
        width: 250px;
        height: 250px;
    }
    
    .control-panel {
        flex-direction: column;
        gap: 20px;
    }
    
    .stats {
        flex-direction: row;
        gap: 20px;
    }
    
    .modal-content {
        width: 95%;
        margin: 10px;
    }
}
    </style>
</head>
<body>
    <div class="game-container">
        <div class="puzzle-container">
            <div class="puzzle-grid" id="puzzleGrid">
                <!-- Puzzle tiles will be generated by JavaScript -->
            </div>
        </div>
        
        <div class="control-panel">
            <div class="stats">
                <div class="stat-box" id="timerBox">
                    <div class="stat-value" id="timer">00:00</div>
                    <div class="stat-label">Timer</div>
                </div>
                <div class="stat-box" id="movesBox">
                    <div class="stat-value" id="moves">0000</div>
                    <div class="stat-label">Moves</div>
                </div>
            </div>
            
            <div class="controls">
                <button class="control-btn" id="shuffleBtn">Shuffle</button>
                <button class="control-btn" id="pauseBtn">Pause</button>
                <button class="control-btn" id="optionsBtn">Options</button>
                <button class="control-btn" id="exitBtn">Exit</button>
            </div>
        </div>
        
        <!-- Options Modal -->
        <div class="modal-overlay" id="optionsModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Options</h2>
                    <button class="close-btn" id="closeOptions">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="option-group">
                        <h3>Display Options</h3>
                        <div class="toggle-option">
                            <label for="timerToggle">Show Timer</label>
                            <input type="checkbox" id="timerToggle" checked>
                            <span class="toggle-slider"></span>
                        </div>
                        <div class="toggle-option">
                            <label for="movesToggle">Show Moves Counter</label>
                            <input type="checkbox" id="movesToggle" checked>
                            <span class="toggle-slider"></span>
                        </div>
                    </div>
                    
                    <div class="option-group">
                        <h3>Tile Colors</h3>
                        <div class="color-option">
                            <label for="oddColorSelect">Odd Numbers Color:</label>
                            <select id="oddColorSelect">
                                <option value="red">Red</option>
                                <option value="blue">Blue</option>
                                <option value="green">Green</option>
                                <option value="purple">Purple</option>
                                <option value="orange">Orange</option>
                                <option value="pink">Pink</option>
                                <option value="teal">Teal</option>
                                <option value="brown">Brown</option>
                            </select>
                        </div>
                        <div class="color-option">
                            <label for="evenColorSelect">Even Numbers Color:</label>
                            <select id="evenColorSelect">
                                <option value="white">White</option>
                                <option value="lightgray">Light Gray</option>
                                <option value="lightblue">Light Blue</option>
                                <option value="lightgreen">Light Green</option>
                                <option value="lightyellow">Light Yellow</option>
                                <option value="lightpink">Light Pink</option>
                                <option value="lightcyan">Light Cyan</option>
                                <option value="beige">Beige</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="control-btn" id="saveOptions">Save</button>
                    <button class="control-btn" id="cancelOptions">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
class SlidePuzzle {
    constructor() {
        this.grid = [];
        this.size = 4;
        this.moves = 0;
        this.timer = 0;
        this.timerInterval = null;
        this.isPaused = false;
        this.isGameStarted = false;
        this.isAnimating = false;
        this.emptyPos = { row: this.size - 1, col: this.size - 1 };
        
        // Options settings
        this.settings = {
            showTimer: true,
            showMoves: true,
            oddColor: 'red',
            evenColor: 'white'
        };
        
        this.loadSettings();
        this.initializeGame();
        this.setupEventListeners();
    }
    
    initializeGame() {
        this.createGrid();
        this.renderGrid();
        this.updateDisplay();
        
        // Check if puzzle is already solved (shouldn't happen with createGrid, but just in case)
        if (this.checkWin()) {
            console.log('Puzzle was already solved on initialization!');
        }
    }
    
    createGrid() {
        this.grid = [];
        for (let i = 0; i < this.size; i++) {
            this.grid[i] = [];
            for (let j = 0; j < this.size; j++) {
                const value = i * this.size + j + 1;
                if (value <= this.size * this.size - 1) {
                    this.grid[i][j] = value;
                } else {
                    this.grid[i][j] = 0; // Empty space
                }
            }
        }
    }
    
    renderGrid() {
        const puzzleGrid = document.getElementById('puzzleGrid');
        puzzleGrid.innerHTML = '';
        
        for (let i = 0; i < this.size; i++) {
            for (let j = 0; j < this.size; j++) {
                const tile = document.createElement('div');
                tile.className = 'puzzle-tile';
                
                if (this.grid[i][j] === 0) {
                    tile.classList.add('empty');
                    tile.textContent = '';
                } else {
                    tile.textContent = this.grid[i][j];
                    if (this.grid[i][j] % 2 === 1) {
                        tile.classList.add('odd', this.settings.oddColor);
                    } else {
                        tile.classList.add('even', this.settings.evenColor);
                    }
                }
                
                tile.dataset.row = i;
                tile.dataset.col = j;
                tile.addEventListener('click', () => this.handleTileClick(i, j));
                
                puzzleGrid.appendChild(tile);
            }
        }
    }
    
    handleTileClick(row, col) {
        if (this.isPaused || !this.isGameStarted || this.isAnimating) return;
        
        if (this.canMove(row, col)) {
            this.moveTile(row, col);
            this.moves++;
            this.updateDisplay();
        }
    }
    
    canMove(row, col) {
        // Check if the clicked tile is adjacent to the empty space
        const rowDiff = Math.abs(row - this.emptyPos.row);
        const colDiff = Math.abs(col - this.emptyPos.col);
        
        return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
    }
    
    moveTile(row, col) {
        // Prevent multiple moves during animation
        if (this.isAnimating) return;
        this.isAnimating = true;
        
        // Get the tile element to animate
        const tileElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (!tileElement) {
            this.isAnimating = false;
            return;
        }
        
        // Calculate the direction and distance to slide
        const direction = this.getSlideDirection(row, col);
        const slideDistance = 76; // Approximate tile size + gap
        
        // Add sliding class and animate
        tileElement.classList.add('sliding');
        
        // Apply transform to slide the tile
        switch (direction) {
            case 'up':
                tileElement.style.transform = `translateY(-${slideDistance}px)`;
                break;
            case 'down':
                tileElement.style.transform = `translateY(${slideDistance}px)`;
                break;
            case 'left':
                tileElement.style.transform = `translateX(-${slideDistance}px)`;
                break;
            case 'right':
                tileElement.style.transform = `translateX(${slideDistance}px)`;
                break;
        }
        
        // Wait for animation to complete, then update the grid
        setTimeout(() => {
            // Swap the clicked tile with the empty space
            const temp = this.grid[row][col];
            this.grid[row][col] = 0;
            this.grid[this.emptyPos.row][this.emptyPos.col] = temp;
            
            // Update empty position
            this.emptyPos = { row, col };
            
            // Re-render the grid
            this.renderGrid();
            this.isAnimating = false;
            
            // Check for win condition after the grid is updated
            if (this.checkWin()) {
                console.log('Calling gameWon() after tile move...');
                this.gameWon();
            }
        }, 300); // Match the CSS transition duration
    }
    
    getSlideDirection(row, col) {
        const rowDiff = row - this.emptyPos.row;
        const colDiff = col - this.emptyPos.col;
        
        if (rowDiff === 1) return 'up';
        if (rowDiff === -1) return 'down';
        if (colDiff === 1) return 'left';
        if (colDiff === -1) return 'right';
        
        return 'up'; // Default fallback
    }
    
    shuffle() {
        this.stopTimer();
        this.moves = 0;
        this.timer = 0;
        this.isGameStarted = false;
        this.isPaused = false;
        
        // Perform random moves to shuffle instantly
        const shuffleMoves = 100;
        for (let i = 0; i < shuffleMoves; i++) {
            const validMoves = this.getValidMoves();
            if (validMoves.length > 0) {
                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                // Move tile without animation for shuffle
                const temp = this.grid[randomMove.row][randomMove.col];
                this.grid[randomMove.row][randomMove.col] = 0;
                this.grid[this.emptyPos.row][this.emptyPos.col] = temp;
                this.emptyPos = { row: randomMove.row, col: randomMove.col };
            }
        }
        
        this.renderGrid();
        this.updateDisplay();
        this.startTimer();
        
        // Check if puzzle is already solved after shuffling
        if (this.checkWin()) {
            console.log('Puzzle was solved after shuffling!');
            this.gameWon();
        }
    }
    
    getValidMoves() {
        const moves = [];
        const { row, col } = this.emptyPos;
        
        // Check all four directions
        const directions = [
            { row: row - 1, col: col },
            { row: row + 1, col: col },
            { row: row, col: col - 1 },
            { row: row, col: col + 1 }
        ];
        
        for (const dir of directions) {
            if (dir.row >= 0 && dir.row < this.size && 
                dir.col >= 0 && dir.col < this.size) {
                moves.push(dir);
            }
        }
        
        return moves;
    }
    
    checkWin() {
        for (let i = 0; i < this.size; i++) {
            for (let j = 0; j < this.size; j++) {
                const expectedValue = i * this.size + j + 1;
                if (i === this.size - 1 && j === this.size - 1) {
                    if (this.grid[i][j] !== 0) return false;
                } else {
                    if (this.grid[i][j] !== expectedValue) return false;
                }
            }
        }
        console.log('Puzzle solved! Win condition detected.');
        return true;
    }
    
    gameWon() {
        console.log('gameWon() method called!');
        this.stopTimer();
        this.isGameStarted = false;
        
        // Add celebration effect to the puzzle grid
        const puzzleGrid = document.getElementById('puzzleGrid');
        puzzleGrid.classList.add('solved');
        
        // Show celebration message
        setTimeout(() => {
            this.showWinMessage();
        }, 500);
    }
    
    showWinMessage() {
        // Create win message overlay
        const winOverlay = document.createElement('div');
        winOverlay.className = 'win-overlay';
        winOverlay.innerHTML = `
            <div class="win-content">
                <h1>🎉 Congratulations! 🎉</h1>
                <p>You solved the puzzle!</p>
                <div class="win-stats">
                    <div class="win-stat">
                        <span class="win-label">Time:</span>
                        <span class="win-value">${this.formatTime(this.timer)}</span>
                    </div>
                    <div class="win-stat">
                        <span class="win-label">Moves:</span>
                        <span class="win-value">${this.moves}</span>
                    </div>
                </div>
                <div class="win-buttons">
                    <button class="control-btn" id="playAgainBtn">Play Again</button>
                    <button class="control-btn" id="closeWinBtn">Close</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(winOverlay);
        
        // Add event listeners for win message buttons
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            document.body.removeChild(winOverlay);
            puzzleGrid.classList.remove('solved');
            this.shuffle();
        });
        
        document.getElementById('closeWinBtn').addEventListener('click', () => {
            document.body.removeChild(winOverlay);
            puzzleGrid.classList.remove('solved');
        });
    }
    
    startTimer() {
        if (!this.timerInterval) {
            this.isGameStarted = true;
            this.timerInterval = setInterval(() => {
                if (!this.isPaused) {
                    this.timer++;
                    this.updateDisplay();
                }
            }, 1000);
        }
    }
    
    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }
    
    togglePause() {
        this.isPaused = !this.isPaused;
        const pauseBtn = document.getElementById('pauseBtn');
        pauseBtn.textContent = this.isPaused ? 'Resume' : 'Pause';
    }
    
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    updateDisplay() {
        document.getElementById('timer').textContent = this.formatTime(this.timer);
        document.getElementById('moves').textContent = this.moves.toString().padStart(4, '0');
        
        // Update visibility based on settings
        const timerBox = document.getElementById('timerBox');
        const movesBox = document.getElementById('movesBox');
        
        if (this.settings.showTimer) {
            timerBox.classList.remove('hidden');
        } else {
            timerBox.classList.add('hidden');
        }
        
        if (this.settings.showMoves) {
            movesBox.classList.remove('hidden');
        } else {
            movesBox.classList.add('hidden');
        }
    }
    
    setupEventListeners() {
        document.getElementById('shuffleBtn').addEventListener('click', () => {
            this.shuffle();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            this.togglePause();
        });
        
        document.getElementById('optionsBtn').addEventListener('click', () => {
            this.openOptions();
        });
        
        // Options modal event listeners
        document.getElementById('closeOptions').addEventListener('click', () => {
            this.closeOptions();
        });
        
        document.getElementById('saveOptions').addEventListener('click', () => {
            this.saveOptions();
        });
        
        document.getElementById('cancelOptions').addEventListener('click', () => {
            this.closeOptions();
        });
        
        // Close modal when clicking outside
        document.getElementById('optionsModal').addEventListener('click', (e) => {
            if (e.target.id === 'optionsModal') {
                this.closeOptions();
            }
        });
        
        document.getElementById('exitBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to exit?')) {
                window.close();
            }
        });
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (this.isPaused || !this.isGameStarted || this.isAnimating) return;
            
            let targetRow = this.emptyPos.row;
            let targetCol = this.emptyPos.col;
            
            switch (e.key) {
                case 'ArrowUp':
                    targetRow = this.emptyPos.row + 1;
                    break;
                case 'ArrowDown':
                    targetRow = this.emptyPos.row - 1;
                    break;
                case 'ArrowLeft':
                    targetCol = this.emptyPos.col + 1;
                    break;
                case 'ArrowRight':
                    targetCol = this.emptyPos.col - 1;
                    break;
                default:
                    return;
            }
            
            if (targetRow >= 0 && targetRow < this.size && 
                targetCol >= 0 && targetCol < this.size) {
                this.moveTile(targetRow, targetCol);
                this.moves++;
                this.updateDisplay();
            }
        });
    }
    
    // Settings management methods
    loadSettings() {
        const saved = localStorage.getItem('slidePuzzleSettings');
        if (saved) {
            this.settings = { ...this.settings, ...JSON.parse(saved) };
        }
    }
    
    saveSettings() {
        localStorage.setItem('slidePuzzleSettings', JSON.stringify(this.settings));
    }
    
    openOptions() {
        // Add event listeners for the form elements first
        this.setupOptionsEventListeners();
        
        // Populate the form with current settings
        document.getElementById('timerToggle').checked = this.settings.showTimer;
        document.getElementById('movesToggle').checked = this.settings.showMoves;
        document.getElementById('oddColorSelect').value = this.settings.oddColor;
        document.getElementById('evenColorSelect').value = this.settings.evenColor;
        
        // Show the modal
        document.getElementById('optionsModal').style.display = 'flex';
    }
    
    closeOptions() {
        document.getElementById('optionsModal').style.display = 'none';
    }
    
    setupOptionsEventListeners() {
        // Remove any existing event listeners to prevent duplicates
        const timerToggle = document.getElementById('timerToggle');
        const movesToggle = document.getElementById('movesToggle');
        const oddColorSelect = document.getElementById('oddColorSelect');
        const evenColorSelect = document.getElementById('evenColorSelect');
        
        // Clone and replace elements to remove old event listeners
        const newTimerToggle = timerToggle.cloneNode(true);
        const newMovesToggle = movesToggle.cloneNode(true);
        const newOddColorSelect = oddColorSelect.cloneNode(true);
        const newEvenColorSelect = evenColorSelect.cloneNode(true);
        
        timerToggle.parentNode.replaceChild(newTimerToggle, timerToggle);
        movesToggle.parentNode.replaceChild(newMovesToggle, movesToggle);
        oddColorSelect.parentNode.replaceChild(newOddColorSelect, oddColorSelect);
        evenColorSelect.parentNode.replaceChild(newEvenColorSelect, evenColorSelect);
        
        // Add new event listeners
        newTimerToggle.addEventListener('change', () => {
            this.settings.showTimer = newTimerToggle.checked;
            this.updateDisplay();
        });
        
        newMovesToggle.addEventListener('change', () => {
            this.settings.showMoves = newMovesToggle.checked;
            this.updateDisplay();
        });
        
        newOddColorSelect.addEventListener('change', () => {
            this.settings.oddColor = newOddColorSelect.value;
            this.renderGrid();
        });
        
        newEvenColorSelect.addEventListener('change', () => {
            this.settings.evenColor = newEvenColorSelect.value;
            this.renderGrid();
        });
        
        // Add click event listeners to the toggle sliders
        const timerSlider = newTimerToggle.nextElementSibling;
        const movesSlider = newMovesToggle.nextElementSibling;
        
        if (timerSlider && timerSlider.classList.contains('toggle-slider')) {
            timerSlider.addEventListener('click', () => {
                newTimerToggle.checked = !newTimerToggle.checked;
                this.settings.showTimer = newTimerToggle.checked;
                this.updateDisplay();
            });
        }
        
        if (movesSlider && movesSlider.classList.contains('toggle-slider')) {
            movesSlider.addEventListener('click', () => {
                newMovesToggle.checked = !newMovesToggle.checked;
                this.settings.showMoves = newMovesSlider.checked;
                this.updateDisplay();
            });
        }
    }
    
    saveOptions() {
        // Get values from form
        this.settings.showTimer = document.getElementById('timerToggle').checked;
        this.settings.showMoves = document.getElementById('movesToggle').checked;
        this.settings.oddColor = document.getElementById('oddColorSelect').value;
        this.settings.evenColor = document.getElementById('evenColorSelect').value;
        
        // Save to localStorage
        this.saveSettings();
        
        // Update display and re-render grid
        this.updateDisplay();
        this.renderGrid();
        
        // Close modal
        this.closeOptions();
    }
}

// Initialize the game when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new SlidePuzzle();
});
    </script>
</body>
</html>
